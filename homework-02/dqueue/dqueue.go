package dqueue

import (
//    "fmt"
//    "context"

    "github.com/go-redis/redis/v8"
//    "github.com/go-zookeeper/zk"

)

/*
 * Можно создавать несколько очередей
 *
 * Для клиента они различаются именами
 * 
 * В реализации они могут потребовать вспомогательных данных
 * Для них - эта структура. Можете определить в ней любые поля 
 */
type DQueue struct {
}

/*
 * Запомнить данные и везде использовать
 */
func Config(redisOptions *redis.Options, zkCluster []string) {
}

/*
 * Открываем очередь на nShards шардах
 *
 * Попытка создать очередь с существующим именем и другим количеством шардов
 * должна приводить к ошибке
 *
 * При попытке создать очередь с существующим именем и тем же количеством шардов
 * нужно вернуть экземпляр DQueue, позволяющий делать Push/Pull
 *
 * Предыдущее открытие может быть совершено другим клиентом, соединенным с любым узлом
 * Redis-кластера
 *
 * Отдельные узлы Redis-кластера могут выпадать. Availability очереди в целом
 * не должна от этого страдать
 *  
 */
func Open(name string, nShards int) (DQueue, error) {
    return DQueue{}, nil
}

/*
 * Пишем в очередь. Каждый следующий Push - в следующий шард
 * 
 * Если шард упал - пропускаем шард, пишем в следующий по очереди
 */
func (*DQueue) Push(value string) error {
    return nil
}

/*
 * Читаем из очереди
 *
 * Из того шарда, в котором самое раннее сообщение
 * 
 */
func (*DQueue) Pull() (string, error) {
    return "", nil
}

