
## Реорганизация микросервиса коротких URL

За основу берем первую домашку.

Если ее нет, делаем с нуля.

За проблемы, унаследованные в силу непроверенности первой домашки,
не будут снижаться баллы.

Мы хотим обрабатывать создание на одном сервере,
а клики - на другом.

Точнее - на нескольких репликах. Именно репликах - в том смысле, что
каждая реплика готова сама обработать редирект по любому выданному
короткому URL.


### Задание 1

/create

/create работает по-прежнему, только на одном из серверов.

Назовем его мастером.

/<короткий url> должен работать на других.

Чтобы они знали, что выдавать, мастер должен передавать им данные
через топик кафки.

Для простоты, мы не думаем о том, что будет в среднесрочной перспективе. 
Какой retention по времени, как вводить в строй новый сервер, если какие-то
старые данные уже умерли по времени.

Просто ставим retention побольше и считаем все, посланное мастером, будет в
топике.


### Задание 2

Редирект

Данные для редиректа будем получать из кафка-топика и сохранять в редисе.
На каждом узле будет работать свой редис на отдельном порту - 26379. 
(чтобы не конфликтовать с теми, кто доделывает вторую домашку и с моими проверкаии) 

При запросе

/<короткий url> GET

Узнаем адрес редиректа из редиса.

Редис один на всех. Поэтому все ключи - с префиксом-именем пользователя.

При первом запуске нужно прочитать весь топик, чтобы получить полное состояние и дочитывать
то, присылает мастер.

Сервер, который работал, выключился и включился снова, должен дочитать пропyщенное.


### Задание 3

Счетчики кликов

Для каждого короткого URL держим в Redis его счетчик кликов
 
После каждого запроса инкрементируем.

Насчитав очередную сотню, отправляем мастеру через отдельный топик.

Топик для счетчиков - один на все сервера.


### Задание 4

Агрегация счетчиков на мастере

Мастер читает обновления из топика и обновляет базу.


### Общие моменты

Если вам хочется менять map из одной горутины и использовать в другой - используйте sync.Map.
(Но не факт, что это потребуется)

В комментариях обоснуйте использованные элементы конфигурации. В кафке очень многое конфигурируется,
в том числе на уровне топика, но для этого задания должно хватить нескольких. Точно меньше десяти
на топик. Скорее всего - сильно меньше.

Обязательно явно укажите количество партиций и обоснуйте в комментарии.

Важным моментом являются гарантии доставки. Об этом говорилось на лекциях. Также в материалах
есть статья про это же. Мы не боремся за чистый exactly-once, потому что это сильно усложняет
задачу.

Но для каждого топика вы должны принять осознанное решение, что лучше из остающихся альтернатив,
реализовать его в конфигурации и описать в комментариях обоснования.

Также надо написать, сильно ли мы проигрываем по сравнению с exactly-once.

Кстати, почему мы используем локальный Redis ? Вместо чистого map-а внутри программы ?
Мы же тратимся сериализацию и хождение через ядро, чтобы пообщаться редисом - даже если это 
localhost.

Во-первых, потому что это чуть более настраиваемое решение. Например, если мы захотим иметь
редис-кластер, отдельный узел, который его заполняет, а остальные - только читают, нам легче это
сделать, отталкиваясь варианта с локальными редиса. А во-вторых - у редиса есть персистентность
и мы можем при возвращении в строй меньше читать из топика (но это не входит в домашку).


### Конфигурация

Postgres живет на узле, адрес которого будет сообщен, на порту 5432. В отличие от кафки и зукипера, этот порт
наружу не виден. Но вам по-любому надо будет логиниться в кластер, чтобы мастера запустить.
Поэтому такое ограничение кажется не очень критичным. Если вы обоснуете, почему оно вам мешает,
я подниму postgres на каком-нибудь другом порту.

В postgres работаем под пользователем postgres без пароля. Создаем базу с именем, равным вышему username.

Редис живет на каждом хосте свой. На порту 26379.

Кафка существует в одиночном исполнении. Адрес будет сообщен дополнительно.

Пример просмотра списка топиков через стандартный клиент: 

```
/opt/kafka/kafka_2.13-3.3.1/bin/kafka-topics.sh --bootstrap-server <ip-адрес кафки>:9092 --list
```

Можно его сопоставит с аналогичным примером из [Kafka: Введение](https://kafka.apache.org/quickstart)
и понять, как адаптировать все остальное.

Что бы работать из клиента, нужно в конфигурации указать

```
bootstrap.servers=<ip-адрес кафки>:9092 
```

При создании топиков добавляем `<usernane>-` в начало имени топика.

В consumer group при чтении - тоже. А если хотите сделать consumer group 
для каждого сервера свою - добавьте IP-адрес в конец имени.
В реальной жизни это не очень правильно, но для простоты сойдет.

Хосты - те же, что  во второй домашке. Любой из них можно выбрать для мастера.
Два других - для обслуживание редиректов.


### Материалы

[Kafka: Введение](https://kafka.apache.org/quickstart)

[Kafka: Подробнее](https://kafka.apache.org/documentation/)

[Kafka Go API](https://docs.confluent.io/platform/current/clients/confluent-kafka-go/index.html)

[Kafka: Гарантии доставки](https://dzone.com/articles/kafka-clients-at-most-once-at-least-once-exactly-o)

[Общее описание Gin Framework](https://gin-gonic.com/docs/)

[API Gin Framework](https://pkg.go.dev/github.com/gin-gonic/gin)

[Базы данных из Go](http://go-database-sql.org/)

[SQL API](https://pkg.go.dev/database/sql)

[Пример простейшего http-клиента](https://gobyexample.com/http-clients)

